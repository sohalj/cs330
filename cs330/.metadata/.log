!SESSION 2014-01-29 18:24:39.854 -----------------------------------------------
eclipse.buildId=debbuild
java.version=1.7.0_25
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.ui.workbench 4 0 2014-01-29 18:31:02.828
!MESSAGE No activeWorkbenchWindow found while executing org.eclipse.ui.file.export
!STACK 0
org.eclipse.core.commands.ExecutionException: No activeWorkbenchWindow found while executing org.eclipse.ui.file.export
	at org.eclipse.ui.handlers.HandlerUtil.noVariableFound(HandlerUtil.java:41)
	at org.eclipse.ui.handlers.HandlerUtil.getVariableChecked(HandlerUtil.java:90)
	at org.eclipse.ui.handlers.HandlerUtil.getActiveWorkbenchWindowChecked(HandlerUtil.java:211)
	at org.eclipse.ui.internal.handlers.WizardHandler.execute(WizardHandler.java:276)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169)
	at org.eclipse.ui.internal.handlers.SlaveHandlerService.executeCommand(SlaveHandlerService.java:241)
	at org.eclipse.ui.internal.actions.CommandAction.runWithEvent(CommandAction.java:157)
	at org.eclipse.ui.internal.actions.CommandAction.run(CommandAction.java:171)
	at org.eclipse.ui.actions.ExportResourcesAction.run(ExportResourcesAction.java:116)
	at org.eclipse.ui.actions.BaseSelectionListenerAction.runWithEvent(BaseSelectionListenerAction.java:168)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1276)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3562)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3186)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.ui.internal.handlers.WizardHandler$Export.executeHandler(WizardHandler.java:103)
	at org.eclipse.ui.internal.handlers.WizardHandler.execute(WizardHandler.java:279)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169)
	at org.eclipse.ui.internal.handlers.SlaveHandlerService.executeCommand(SlaveHandlerService.java:241)
	at org.eclipse.ui.internal.actions.CommandAction.runWithEvent(CommandAction.java:157)
	at org.eclipse.ui.internal.actions.CommandAction.run(CommandAction.java:171)
	at org.eclipse.ui.actions.ExportResourcesAction.run(ExportResourcesAction.java:116)
	at org.eclipse.ui.actions.BaseSelectionListenerAction.runWithEvent(BaseSelectionListenerAction.java:168)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1276)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3562)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3186)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1414)
!SESSION 2014-03-06 15:58:06.005 -----------------------------------------------
eclipse.buildId=debbuild
java.version=1.7.0_25
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.jdt.core 4 4 2014-03-06 16:38:04.862
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package base;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Scanner;





public class Assignment3 {
	public static Connection connSource, connDest;
	
	public static void main(String[] args) {
		try {
			TickerData range;
			ArrayList<TickerData> finalStocks;
			String[] connString = MagicStrings.getStockDBStrings();
			connSource = DriverManager.getConnection(connString[0].trim(), connString[1].trim(), connString[2].trim());
			connString = MagicStrings.getNewDBStrings();
			connDest = DriverManager.getConnection(connString[0].trim(), connString[1].trim(), connString[2].trim());
			System.out.println("Database connections established");
			
			Statement st = connDest.createStatement();
			try {
				st.executeUpdate("drop table performance");
			}
			catch(SQLException ex) {
				
			}
			System.out.println("Destination database cleared of tables");

			Statement stat = connDest.createStatement();
			stat.executeUpdate("create table performance (Industry char(30), Ticker char(6), StartDate char(10), EndDate char(10), TickerReturn char(12), IndustryReturn char(12))");
			System.out.println("Destination table ready");
			
			//PreparedStatement companyStat = connSource.prepareStatement("select * from company where ticker = ?");
			Scanner keyboard = new Scanner(System.in);
			System.out.print("Enter a ticker symbol: ");
			String ticker = keyboard.nextLine().trim();
			//while (!ticker.matches("")) {
				//companyStat.setString(1, ticker);
				//ResultSet companyName = companyStat.executeQuery();
				//if (!companyName.next()) 
					//System.out.println(ticker + " not found in database");
				//else {
					System.out.println("Adjusting data for splits");
					range = recordSplits(ticker); 
					finalStocks = displaySplits(ticker, range);
					getTransDate(ticker, finalStocks);
					System.out.println("splits for " + ticker + " recorded");
					System.out.println("Readout of recorded splits is");
					recoverSplits(ticker);
				
				//}
				//System.out.print("\nEnter a ticker symbol: ");
			////	ticker = keyboard.nextLine().trim();
			//}
			
			connSource.close(); 
			connDest.close();
			System.out.println("Database connections closed");
			keyboard.close();
		}
		catch (SQLException ex) {
			System.out.println("SQL exception");
			ex.printStackTrace();
			return;
		}
	}
	
	private static TickerData recordSplits(String ticker) { // checks for 2:1, 3:1, and 3:2 splits
		TickerData data;
		TickerData dates = new TickerData();
		ArrayList<TickerData> dataArray = new ArrayList<TickerData>();
		String min = null;
		String max = null;
		try {
			PreparedStatement priceStat = connSource.prepareStatement("select Ticker, min(TransDate), max(TransDate), count(distinct TransDate) as tradingDays from company natural join pricevolume where Industry = 'Telecommunications Services'group by Ticker having tradingDays >= 150 order by Ticker");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			//priceStat.setString(1, ticker);
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				System.out.println("no data");
			else {
				data = extractData(rs);
				System.out.print(data.ticker + "	");
				System.out.print(data.startDate + "	");
				System.out.print(data.endDate + "	");
				System.out.println(data.numDays);
				dataArray.add(data);
			}	
				while (rs.next()) {
					data = extractData(rs);
					System.out.print(data.ticker + "	");
					System.out.print(data.startDate + "	");
					System.out.print(data.endDate + "	");
					System.out.println(data.numDays);
					dataArray.add(data);
					
					
				}
				System.out.println(dataArray.size());
				min = dataArray.get(0).startDate;
				max = dataArray.get(0).endDate;
				for(int i=0; i < dataArray.size()-1; i++){
					
					if(min.compareTo(dataArray.get(i+1).startDate) < 0){
						 min = dataArray.get(i+1).startDate;
					}
					
					if((max.compareTo(dataArray.get(i+1).endDate) > 0) || max.compareTo(dataArray.get(i+1).endDate) == 0){
						 max = dataArray.get(i).endDate;
					}
					

				}
				System.out.println(min + " min Final");
				System.out.println(max + " max Final");
				
				dates.startDate = min;
				dates.endDate = max;
			//}
			//double epsilon = 0.13; // ratio must be this close to 2, 3, or 1.5 to signal a split
			//double nextOpen = data.price[0];
			/**while (rs.next()) {
				data = extractData(rs);
				double open = nextOpen;
				double close = data.price[3];
				double ratio = close/open;
				nextOpen = data.price[0];
				String splitRatio = "";
				if (Math.abs(ratio - 2.0) < epsilon)
					splitRatio = "2:1 ";
				else if (Math.abs(ratio - 3.0) < epsilon) 
					splitRatio = "3:1 ";
				else if (Math.abs(ratio - 1.5) < epsilon)
					splitRatio = "3:2 ";
				if (splitRatio.length() > 0) {
					System.out.print(splitRatio + "split on " + data.date);
					System.out.print("; " + String.format("%7.2f", close));
					System.out.println(" --> " + String.format("%7.2f", open));
					splitStat.setString(2, data.date);
					splitStat.setString(3, splitRatio);
					splitStat.setString(4, String.format("%12.2f", close).trim());
					splitStat.setString(5, String.format("%12.2f", open).trim());
					splitStat.execute();
				}
			}*/
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in recordSplits");
		}
		return dates;
	}
	
	
	
	private static ArrayList<TickerData> displaySplits(String ticker, TickerData range) { // checks for 2:1, 3:1, and 3:2 splits
		TickerData data = range;
		String start = data.startDate;
		String end = data.endDate;
		
		//TickerData dates = new TickerData();
		ArrayList<TickerData> dataArray = new ArrayList<TickerData>();
		try {
			PreparedStatement priceStat = connSource.prepareStatement("select Ticker, min(TransDate), max(TransDate), count(distinct TransDate) as tradingDays from company natural join pricevolume where Industry = 'Telecommunications Services'and TransDate>= ? and TransDate <= ? group by Ticker having tradingDays >= 150 order by Ticker");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			priceStat.setString(1, start);
			priceStat.setString(2, end);			
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				System.out.println("no Data");
			else {
				data = extractData(rs);
				System.out.print(data.ticker + "	");
				System.out.print(data.startDate + "	");
				System.out.print(data.endDate + "	");
				System.out.println(data.numDays);
				dataArray.add(data);
			}	
				while (rs.next()) {
					data = extractData(rs);
					//System.out.print(data.ticker + "	");
					//System.out.print(data.startDate + "	");
					//System.out.print(data.endDate + "	");
					System.out.println(data.numDays);
					dataArray.add(data);
					
					
				}
				System.out.println(dataArray.size());
				
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in displaySplits");
		}
		return dataArray;
	}
	
	
	
	
	
	
	private static void getTransDate(String ticker, ArrayList<TickerData> finalStocks) { // checks for 2:1, 3:1, and 3:2 splits
		ArrayList<TickerData> stocks = finalStocks;
		String start = stocks.get(0).startDate;
		String end = stocks.get(0).endDate;
		//String firstTicker = stocks.get(0).ticker;
		double open =0.0;
		double close = 0.0;
		int j = 0;
		String mTicker = stocks.get(0).ticker;
		TickerPrice priceData;
		ArrayList<TickerPrice> priceArray = new ArrayList<TickerPrice>();
		ArrayList<ReturnValue> returnArray = new ArrayList<ReturnValue>();
		ArrayList<IntervalData> intervalArray = new ArrayList<IntervalData>();
		double iReturn = 0.0;
		int numStocks =0;
		try {
			//for(int m = 0; m < stocks.size(); m++){
				//if (m == 0){
			PreparedStatement priceStat = connSource.prepareStatement("select P.ticker, P.TransDate, P.openPrice, P.closePrice from pricevolume P where Ticker = ? and TransDate >= ? and TransDate <= ?");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			priceStat.setString(1, stocks.get(0).ticker);
			priceStat.setString(2, start);
			priceStat.setString(3, end);
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				return;
			else {
				priceData = extractDataPrice(rs);
				System.out.print(priceData.ticker + "	");
				System.out.print(priceData.transDate + "	");
				System.out.print(priceData.open + "	");
				System.out.println(priceData.close);
				priceArray.add(priceData);
			}	
			
			while (rs.next()) {
					priceData = extractDataPrice(rs);
					System.out.print(priceData.ticker + "	");
					System.out.print(priceData.transDate + "	");
					System.out.print(priceData.open + "	");
					System.out.println(priceData.close);
					priceArray.add(priceData);
			}
			
			/*
			for(int i = 0; i <stocks.get(0).numDays/60; i++){
				System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					j=j+60;
			}
			 test for correct out puts*/
			
			
			for(int i = 0; i <stocks.get(0).numDays/60; i++){
					IntervalData interval = new IntervalData();
					//System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					//System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					//System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					interval.open = priceArray.get(j).transDate;
					interval.close = priceArray.get(j+59).transDate;
					intervalArray.add(interval);
					
					j=j+60;
			}
			/*
			for(int f = 0; f < intervalArray.size(); f++){
				System.out.println(intervalArray.get(f).open + "     " + intervalArray.get(f).close + "    " + f );
			} test for write intervals */
			
		
			//	}
			for(int m = 1; m < stocks.size(); m++){
				//else{
					PreparedStatement priceStat1 = connSource.prepareStatement("select P.ticker,P.TransDate, P.openPrice, P.closePrice from pricevolume P where Ticker = ? and TransDate >= ? and TransDate <= ?");
					//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
					//splitStat.setString(1, ticker);
					priceStat1.setString(1, stocks.get(m).ticker);
					priceStat1.setString(2, start);
					priceStat1.setString(3, end);
					ResultSet rs1 = priceStat1.executeQuery();
					System.out.println("fuckasdfsdaf");
					if (!rs1.next())
						return;
					else {
						priceData = extractDataPrice(rs1);
						//System.out.print(priceData.ticker + "	");
						//System.out.print(priceData.transDate + "	");
						//System.out.print(priceData.open + "	");
						//System.out.println(priceData.close);
						priceArray.add(priceData);
					}	
					
					while (rs1.next()) {
							priceData = extractDataPrice(rs1);
							//System.out.print(priceData.ticker + "	");
							//System.out.print(priceData.transDate + "	");
							//System.out.print(priceData.open + "	");
							//System.out.println(priceData.close);
							priceArray.add(priceData);
					}
					
					
					
							
					
					
				}
			
			
			
			for(int s = 0; s <stocks.size(); s++){
				String t = stocks.get(s).ticker;
				for(int k = 0; k <intervalArray.size(); k++){
					ReturnValue rv = new ReturnValue();
					for(int n = 0; n < priceArray.size(); n++){
						if(priceArray.get(n).ticker.equals(t)){
							if(priceArray.get(n).transDate.equals(intervalArray.get(k).open)){
								 open = priceArray.get(n).open;
								// System.out.println(priceArray.get(n).transDate + " asd");
							}
							if(priceArray.get(n).transDate.equals(intervalArray.get(k).close)){
								 close = priceArray.get(n).close;
								// System.out.println(priceArray.get(n).transDate + " mnb");
							}
						}
					}
					//System.out.println(intervalArray.get(k).open + " fuck asdfsadfsadf ");
					//System.out.println(intervalArray.get(k).close);
					rv.ticker = t;
					rv.iReturn = (close/open)-1;
					returnArray.add(rv);
				}
			}
			System.out.println(returnArray.size() + " return array size");
			
			
			
			for(int f = 0; f < returnArray.size(); f++){
				//System.out.println(returnArray.get(f).ticker + "     " + returnArray.get(f).iReturn + "    " + f );
				//double value = ((returnArray.get(38).iReturn + returnArray.get(75).iReturn + returnArray.get(112).iReturn + returnArray.get(149).iReturn  + returnArray.get(186).iReturn)/5);  
			
				//System.out.println(value);
			} 
			
			
			
			
			
			
	
			
			
			
			
			
			
			
			
		/*	
			for(int i = 0; i <stocks.get(0).numDays*stocks.size()/60; i++){
				System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					j=j+60;
			}
			*/
			
			/*
			for(int n = 0; n<stocks.size(); n++){
				mTicker = stocks.get(n).ticker;
				for(int g = 0; g<returnArray.size(); g++){
					if(returnArray.get(g).ticker != mTicker){
						 iReturn = iReturn + returnArray.get(g).iReturn;
						 numStocks++;
						 if(numStocks == stocks.size()-1){
							 iReturn = ((1/numStocks) * iReturn) - 1;
						 }
					}
				}
				//System.out.println(iReturn);
				
			}*/
			
			for(int n = 0; n <stocks.size(); n++){
				for(int g = 0; g<=stocks.get(0(numDays/60; g++){
					
				}
					
			}
			
			
			
			
		//	}
			System.out.println(priceArray.size() + " pricearraysize");
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in displaySplits");
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	private static void recoverSplits(String ticker) {
		try {
			PreparedStatement checkStat = connDest.prepareStatement("select * from splits where ticker = ?");
			checkStat.setString(1, ticker);
			ResultSet rs = checkStat.executeQuery();
			while (rs.next()) {
				System.out.println(rs.getString(3).trim() + " split on " + rs.getString(2).trim() + ";  " + rs.getString(4).trim() + " --> " + rs.getString(5).trim());
			}
			System.out.println();
		}
		catch(SQLException ex) {
			System.out.println("SQL exception in recoverSplits");
		}
	}
	

	
	private static TickerPrice extractDataPrice(ResultSet rs) {
		TickerPrice result = new TickerPrice();
		
		
		try {
			ResultSetMetaData rsmd = rs.getMetaData();
			int numberOfColumns = rsmd.getColumnCount();
			if(numberOfColumns == 4){
			result.ticker = rs.getString(1).trim();
			result.transDate = rs.getString(2).trim();
			result.open =  Double.parseDouble(rs.getString(3).trim());
			result.close = Double.parseDouble(rs.getString(4).trim());
			}
			else{
				result.ticker = rs.getString(1).trim();
				//result.transDate = rs.getString(2).trim();
				result.open =  Double.parseDouble(rs.getString(2).trim());
				result.close = Double.parseDouble(rs.getString(3).trim());	
				
			}
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in extractStrings");
		}
		return result;
	}


	
	
	
	
	
	
	
	
	
	
	
	
	private static TickerData extractData(ResultSet rs) {
		TickerData result = new TickerData();
		try {
			result.ticker = rs.getString(1).trim();
			result.startDate = rs.getString(2).trim();
			result.endDate =  rs.getString(3).trim();
			result.numDays = Integer.parseInt(rs.getString(4).trim());
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in extractStrings");
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-06 16:38:04.889
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-06 16:38:04.891
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-06 16:38:04.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package base;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Scanner;





public class Assignment3 {
	public static Connection connSource, connDest;
	
	public static void main(String[] args) {
		try {
			TickerData range;
			ArrayList<TickerData> finalStocks;
			String[] connString = MagicStrings.getStockDBStrings();
			connSource = DriverManager.getConnection(connString[0].trim(), connString[1].trim(), connString[2].trim());
			connString = MagicStrings.getNewDBStrings();
			connDest = DriverManager.getConnection(connString[0].trim(), connString[1].trim(), connString[2].trim());
			System.out.println("Database connections established");
			
			Statement st = connDest.createStatement();
			try {
				st.executeUpdate("drop table performance");
			}
			catch(SQLException ex) {
				
			}
			System.out.println("Destination database cleared of tables");

			Statement stat = connDest.createStatement();
			stat.executeUpdate("create table performance (Industry char(30), Ticker char(6), StartDate char(10), EndDate char(10), TickerReturn char(12), IndustryReturn char(12))");
			System.out.println("Destination table ready");
			
			//PreparedStatement companyStat = connSource.prepareStatement("select * from company where ticker = ?");
			Scanner keyboard = new Scanner(System.in);
			System.out.print("Enter a ticker symbol: ");
			String ticker = keyboard.nextLine().trim();
			//while (!ticker.matches("")) {
				//companyStat.setString(1, ticker);
				//ResultSet companyName = companyStat.executeQuery();
				//if (!companyName.next()) 
					//System.out.println(ticker + " not found in database");
				//else {
					System.out.println("Adjusting data for splits");
					range = recordSplits(ticker); 
					finalStocks = displaySplits(ticker, range);
					getTransDate(ticker, finalStocks);
					System.out.println("splits for " + ticker + " recorded");
					System.out.println("Readout of recorded splits is");
					recoverSplits(ticker);
				
				//}
				//System.out.print("\nEnter a ticker symbol: ");
			////	ticker = keyboard.nextLine().trim();
			//}
			
			connSource.close(); 
			connDest.close();
			System.out.println("Database connections closed");
			keyboard.close();
		}
		catch (SQLException ex) {
			System.out.println("SQL exception");
			ex.printStackTrace();
			return;
		}
	}
	
	private static TickerData recordSplits(String ticker) { // checks for 2:1, 3:1, and 3:2 splits
		TickerData data;
		TickerData dates = new TickerData();
		ArrayList<TickerData> dataArray = new ArrayList<TickerData>();
		String min = null;
		String max = null;
		try {
			PreparedStatement priceStat = connSource.prepareStatement("select Ticker, min(TransDate), max(TransDate), count(distinct TransDate) as tradingDays from company natural join pricevolume where Industry = 'Telecommunications Services'group by Ticker having tradingDays >= 150 order by Ticker");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			//priceStat.setString(1, ticker);
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				System.out.println("no data");
			else {
				data = extractData(rs);
				System.out.print(data.ticker + "	");
				System.out.print(data.startDate + "	");
				System.out.print(data.endDate + "	");
				System.out.println(data.numDays);
				dataArray.add(data);
			}	
				while (rs.next()) {
					data = extractData(rs);
					System.out.print(data.ticker + "	");
					System.out.print(data.startDate + "	");
					System.out.print(data.endDate + "	");
					System.out.println(data.numDays);
					dataArray.add(data);
					
					
				}
				System.out.println(dataArray.size());
				min = dataArray.get(0).startDate;
				max = dataArray.get(0).endDate;
				for(int i=0; i < dataArray.size()-1; i++){
					
					if(min.compareTo(dataArray.get(i+1).startDate) < 0){
						 min = dataArray.get(i+1).startDate;
					}
					
					if((max.compareTo(dataArray.get(i+1).endDate) > 0) || max.compareTo(dataArray.get(i+1).endDate) == 0){
						 max = dataArray.get(i).endDate;
					}
					

				}
				System.out.println(min + " min Final");
				System.out.println(max + " max Final");
				
				dates.startDate = min;
				dates.endDate = max;
			//}
			//double epsilon = 0.13; // ratio must be this close to 2, 3, or 1.5 to signal a split
			//double nextOpen = data.price[0];
			/**while (rs.next()) {
				data = extractData(rs);
				double open = nextOpen;
				double close = data.price[3];
				double ratio = close/open;
				nextOpen = data.price[0];
				String splitRatio = "";
				if (Math.abs(ratio - 2.0) < epsilon)
					splitRatio = "2:1 ";
				else if (Math.abs(ratio - 3.0) < epsilon) 
					splitRatio = "3:1 ";
				else if (Math.abs(ratio - 1.5) < epsilon)
					splitRatio = "3:2 ";
				if (splitRatio.length() > 0) {
					System.out.print(splitRatio + "split on " + data.date);
					System.out.print("; " + String.format("%7.2f", close));
					System.out.println(" --> " + String.format("%7.2f", open));
					splitStat.setString(2, data.date);
					splitStat.setString(3, splitRatio);
					splitStat.setString(4, String.format("%12.2f", close).trim());
					splitStat.setString(5, String.format("%12.2f", open).trim());
					splitStat.execute();
				}
			}*/
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in recordSplits");
		}
		return dates;
	}
	
	
	
	private static ArrayList<TickerData> displaySplits(String ticker, TickerData range) { // checks for 2:1, 3:1, and 3:2 splits
		TickerData data = range;
		String start = data.startDate;
		String end = data.endDate;
		
		//TickerData dates = new TickerData();
		ArrayList<TickerData> dataArray = new ArrayList<TickerData>();
		try {
			PreparedStatement priceStat = connSource.prepareStatement("select Ticker, min(TransDate), max(TransDate), count(distinct TransDate) as tradingDays from company natural join pricevolume where Industry = 'Telecommunications Services'and TransDate>= ? and TransDate <= ? group by Ticker having tradingDays >= 150 order by Ticker");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			priceStat.setString(1, start);
			priceStat.setString(2, end);			
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				System.out.println("no Data");
			else {
				data = extractData(rs);
				System.out.print(data.ticker + "	");
				System.out.print(data.startDate + "	");
				System.out.print(data.endDate + "	");
				System.out.println(data.numDays);
				dataArray.add(data);
			}	
				while (rs.next()) {
					data = extractData(rs);
					//System.out.print(data.ticker + "	");
					//System.out.print(data.startDate + "	");
					//System.out.print(data.endDate + "	");
					System.out.println(data.numDays);
					dataArray.add(data);
					
					
				}
				System.out.println(dataArray.size());
				
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in displaySplits");
		}
		return dataArray;
	}
	
	
	
	
	
	
	private static void getTransDate(String ticker, ArrayList<TickerData> finalStocks) { // checks for 2:1, 3:1, and 3:2 splits
		ArrayList<TickerData> stocks = finalStocks;
		String start = stocks.get(0).startDate;
		String end = stocks.get(0).endDate;
		//String firstTicker = stocks.get(0).ticker;
		double open =0.0;
		double close = 0.0;
		int j = 0;
		String mTicker = stocks.get(0).ticker;
		TickerPrice priceData;
		ArrayList<TickerPrice> priceArray = new ArrayList<TickerPrice>();
		ArrayList<ReturnValue> returnArray = new ArrayList<ReturnValue>();
		ArrayList<IntervalData> intervalArray = new ArrayList<IntervalData>();
		double iReturn = 0.0;
		int numStocks =0;
		try {
			//for(int m = 0; m < stocks.size(); m++){
				//if (m == 0){
			PreparedStatement priceStat = connSource.prepareStatement("select P.ticker, P.TransDate, P.openPrice, P.closePrice from pricevolume P where Ticker = ? and TransDate >= ? and TransDate <= ?");
			//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
			//splitStat.setString(1, ticker);
			priceStat.setString(1, stocks.get(0).ticker);
			priceStat.setString(2, start);
			priceStat.setString(3, end);
			ResultSet rs = priceStat.executeQuery();
			System.out.println("fuckasdfsdaf");
			if (!rs.next())
				return;
			else {
				priceData = extractDataPrice(rs);
				System.out.print(priceData.ticker + "	");
				System.out.print(priceData.transDate + "	");
				System.out.print(priceData.open + "	");
				System.out.println(priceData.close);
				priceArray.add(priceData);
			}	
			
			while (rs.next()) {
					priceData = extractDataPrice(rs);
					System.out.print(priceData.ticker + "	");
					System.out.print(priceData.transDate + "	");
					System.out.print(priceData.open + "	");
					System.out.println(priceData.close);
					priceArray.add(priceData);
			}
			
			/*
			for(int i = 0; i <stocks.get(0).numDays/60; i++){
				System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					j=j+60;
			}
			 test for correct out puts*/
			
			
			for(int i = 0; i <stocks.get(0).numDays/60; i++){
					IntervalData interval = new IntervalData();
					//System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					//System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					//System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					interval.open = priceArray.get(j).transDate;
					interval.close = priceArray.get(j+59).transDate;
					intervalArray.add(interval);
					
					j=j+60;
			}
			/*
			for(int f = 0; f < intervalArray.size(); f++){
				System.out.println(intervalArray.get(f).open + "     " + intervalArray.get(f).close + "    " + f );
			} test for write intervals */
			
		
			//	}
			for(int m = 1; m < stocks.size(); m++){
				//else{
					PreparedStatement priceStat1 = connSource.prepareStatement("select P.ticker,P.TransDate, P.openPrice, P.closePrice from pricevolume P where Ticker = ? and TransDate >= ? and TransDate <= ?");
					//PreparedStatement splitStat = connDest.prepareStatement("insert into splits values (?, ?, ?, ?, ?)");
					//splitStat.setString(1, ticker);
					priceStat1.setString(1, stocks.get(m).ticker);
					priceStat1.setString(2, start);
					priceStat1.setString(3, end);
					ResultSet rs1 = priceStat1.executeQuery();
					System.out.println("fuckasdfsdaf");
					if (!rs1.next())
						return;
					else {
						priceData = extractDataPrice(rs1);
						//System.out.print(priceData.ticker + "	");
						//System.out.print(priceData.transDate + "	");
						//System.out.print(priceData.open + "	");
						//System.out.println(priceData.close);
						priceArray.add(priceData);
					}	
					
					while (rs1.next()) {
							priceData = extractDataPrice(rs1);
							//System.out.print(priceData.ticker + "	");
							//System.out.print(priceData.transDate + "	");
							//System.out.print(priceData.open + "	");
							//System.out.println(priceData.close);
							priceArray.add(priceData);
					}
					
					
					
							
					
					
				}
			
			
			
			for(int s = 0; s <stocks.size(); s++){
				String t = stocks.get(s).ticker;
				for(int k = 0; k <intervalArray.size(); k++){
					ReturnValue rv = new ReturnValue();
					for(int n = 0; n < priceArray.size(); n++){
						if(priceArray.get(n).ticker.equals(t)){
							if(priceArray.get(n).transDate.equals(intervalArray.get(k).open)){
								 open = priceArray.get(n).open;
								// System.out.println(priceArray.get(n).transDate + " asd");
							}
							if(priceArray.get(n).transDate.equals(intervalArray.get(k).close)){
								 close = priceArray.get(n).close;
								// System.out.println(priceArray.get(n).transDate + " mnb");
							}
						}
					}
					//System.out.println(intervalArray.get(k).open + " fuck asdfsadfsadf ");
					//System.out.println(intervalArray.get(k).close);
					rv.ticker = t;
					rv.iReturn = (close/open)-1;
					returnArray.add(rv);
				}
			}
			System.out.println(returnArray.size() + " return array size");
			
			
			
			for(int f = 0; f < returnArray.size(); f++){
				//System.out.println(returnArray.get(f).ticker + "     " + returnArray.get(f).iReturn + "    " + f );
				//double value = ((returnArray.get(38).iReturn + returnArray.get(75).iReturn + returnArray.get(112).iReturn + returnArray.get(149).iReturn  + returnArray.get(186).iReturn)/5);  
			
				//System.out.println(value);
			} 
			
			
			
			
			
			
	
			
			
			
			
			
			
			
			
		/*	
			for(int i = 0; i <stocks.get(0).numDays*stocks.size()/60; i++){
				System.out.println(priceArray.get(j).transDate + "    " + "opendate");
					System.out.println(priceArray.get(j+59).transDate + "    " +  "close date");
					//System.out.println(priceArray.get(j).transDate + "    " + "open date");
					System.out.println((priceArray.get(j+59).close/priceArray.get(j).open)-1 + "       " + i + "    " + priceArray.get(j+59).ticker);
					j=j+60;
			}
			*/
			
			/*
			for(int n = 0; n<stocks.size(); n++){
				mTicker = stocks.get(n).ticker;
				for(int g = 0; g<returnArray.size(); g++){
					if(returnArray.get(g).ticker != mTicker){
						 iReturn = iReturn + returnArray.get(g).iReturn;
						 numStocks++;
						 if(numStocks == stocks.size()-1){
							 iReturn = ((1/numStocks) * iReturn) - 1;
						 }
					}
				}
				//System.out.println(iReturn);
				
			}*/
			
			for(int n = 0; n <stocks.size(); n++){
				for(int g = 0; g<=stocks.get(0(numDays/60; g++){
					
				}
					
			}
			
			
			
			
		//	}
			System.out.println(priceArray.size() + " pricearraysize");
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in displaySplits");
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	private static void recoverSplits(String ticker) {
		try {
			PreparedStatement checkStat = connDest.prepareStatement("select * from splits where ticker = ?");
			checkStat.setString(1, ticker);
			ResultSet rs = checkStat.executeQuery();
			while (rs.next()) {
				System.out.println(rs.getString(3).trim() + " split on " + rs.getString(2).trim() + ";  " + rs.getString(4).trim() + " --> " + rs.getString(5).trim());
			}
			System.out.println();
		}
		catch(SQLException ex) {
			System.out.println("SQL exception in recoverSplits");
		}
	}
	

	
	private static TickerPrice extractDataPrice(ResultSet rs) {
		TickerPrice result = new TickerPrice();
		
		
		try {
			ResultSetMetaData rsmd = rs.getMetaData();
			int numberOfColumns = rsmd.getColumnCount();
			if(numberOfColumns == 4){
			result.ticker = rs.getString(1).trim();
			result.transDate = rs.getString(2).trim();
			result.open =  Double.parseDouble(rs.getString(3).trim());
			result.close = Double.parseDouble(rs.getString(4).trim());
			}
			else{
				result.ticker = rs.getString(1).trim();
				//result.transDate = rs.getString(2).trim();
				result.open =  Double.parseDouble(rs.getString(2).trim());
				result.close = Double.parseDouble(rs.getString(3).trim());	
				
			}
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in extractStrings");
		}
		return result;
	}


	
	
	
	
	
	
	
	
	
	
	
	
	private static TickerData extractData(ResultSet rs) {
		TickerData result = new TickerData();
		try {
			result.ticker = rs.getString(1).trim();
			result.startDate = rs.getString(2).trim();
			result.endDate =  rs.getString(3).trim();
			result.numDays = Integer.parseInt(rs.getString(4).trim());
		}
		catch (SQLException ex) {
			System.out.println("SQL exception in extractStrings");
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-06 16:38:04.931
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-06 16:38:04.933
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1088)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1593)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2897)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1508)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:938)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1539)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2451)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2381)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1757)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2402)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1104)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2565)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2423)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
